package game

import (
	"encoding/json"
	"errors"
	"fmt"
	"log"
	FirebaseFunction "majampachinkogame/Firebase"
	"majampachinkogame/Packet"
	"math/rand"
	"net"
	"os"
	"runtime/debug"
	"runtime/pprof"
	"strconv"
	"strings"
	"sync"
	"time"
)

const PLAYER_NUMBER int = 4
const (
	TellTimeOut = 1 // 單位是分鐘
)

type ServerState int

const (
	NoneInit ServerState = iota
	StartGame
	StartRound
	DealCard
	NotifyHeavenListen
	EndHeavenListen
	NotifyDiscardTile
	EndDiscardTile
	NotifyRobWin
	EndRobWin
	NotifyAfterDiscard
	EndAfterDiscard
	NotifyWinInfo
	WaitNextRound
	WaitNotifyEndGame
	NotifyEndGame
	WaitOneMoreGame
	ShutdownServer
)

type PlayRound int

const (
	PlayOneBa PlayRound = iota
	PlayOneQuan
	PlayOneJiang
)

const MAX_ALLOW_DISCONNECT_TIME float64 = 20.0
const ADD_THINK_TIME float64 = 2.0
const REMAIN_TILE_FOR_CHOW_PONG_KONG int = 3
const REMAIN_TILE_FOR_KONGSELF int = 1
const AI_WAIT_TIME_MIN float64 = 2
const AI_WAIT_TIME_MAX float64 = 4
const AI_EMOJI_DELAY_MIN float64 = 2500
const AI_EMOJI_DELAY_MAX float64 = 6000

const NEXT_ROUND_WAIT_TIME = 5
const NEXT_ROUND_WAIT_TIME_ADD_TAI = 1
const NEXT_ROUND_WAIT_TIME_ADD_SORT = 7

type GameRoom struct {
	RoomName               string
	FirebaseDocID          string
	serverState            ServerState
	playerList             [PLAYER_NUMBER]Player //connectIndex
	jamData                OneJamData
	RoomWaitTime           float64
	RoomPlayRound          RoundEnum
	roundData              *OneRoundData
	WaitPlayerFlag         [PLAYER_NUMBER]bool
	WaitOpenDiscardSeaFlag [PLAYER_NUMBER]bool
	WaitPlayerTime         [PLAYER_NUMBER]float64
	TellPlayerAction       [PLAYER_NUMBER]*TellPlayerActionPacket
	WaitPlayerAction       [PLAYER_NUMBER]chan PlayerAction
	ActionPacketID         int
	//afterPlayerActionEvent         func()
	isFirstDealer                  bool
	lastPlayerActionType           PlayerActionType
	lastDiscardTileID              int
	currentActionPlayer            int
	currentPlayerDrawTile          int
	currentPlayerCanAction         PlayerActionType
	recievePlayerActions           []PlayerAction
	winActions                     []PlayerAction
	isPlayingRound                 bool
	anyPlayerCanRobWin             bool
	anyPlayerCanActionAfterDiscard bool
	GameRoomSetting                GameSetting
	ServerTime                     float64
	WaitNextRoundTime              int
	MutexLock                      sync.Mutex
	DebugIsRunning                 bool
	DebugLastState                 ServerState
	isCurrentPlayerKongOther       bool
	lastChangeStateTime            time.Time
	AllowAbandonRoom               bool
	SpecialTrigger                 int
	SpecialTriggerRound            []bool
	ErrorLogs                      []string
}

func (g *GameRoom) Init(gameSetting GameSetting) {
	g.recievePlayerActions = make([]PlayerAction, 0, 4)

	g.GameRoomSetting = gameSetting
	g.GameRoomSetting.MaxLeaveTime = MAX_ALLOW_DISCONNECT_TIME

	g.RoomWaitTime = gameSetting.ThinkTime

	switch RoundEnum(gameSetting.Round) {
	case Round_Ba:
		g.RoomPlayRound = Round_Ba
	case Round_Quan:
		g.RoomPlayRound = Round_Quan
	default:
		g.RoomPlayRound = Round_Ba
	}

	strs := strings.Split(gameSetting.Bet, "/")
	if len(strs) == 2 {
		var err error
		g.GameRoomSetting.Ante, err = strconv.Atoi(strs[0])
		g.GameRoomSetting.OnePointScore, err = strconv.Atoi(strs[1])
		if err != nil {
			fmt.Println("GameRoom Init WRONG with gameSetting.Bet == ", gameSetting.Bet)
			g.GameRoomSetting.Ante = 50
			g.GameRoomSetting.OnePointScore = 20
		}
	} else {
		fmt.Println("GameRoom Init WRONG with gameSetting.Bet == ", gameSetting.Bet)
		g.GameRoomSetting.Ante = 50
		g.GameRoomSetting.OnePointScore = 20
	}

	g.ServerTime = 0
}

func (g *GameRoom) SetRoomName(roomName string) {
	g.RoomName = roomName
}

func (g *GameRoom) SetDocumentID(docID string) {
	g.FirebaseDocID = docID
}

func (g *GameRoom) SetPlayers(playerIDs [PLAYER_NUMBER]string, outputPlayerUID [PLAYER_NUMBER]string) {
	realPlayer := 0
	specialUID := ""
	for i := 0; i < PLAYER_NUMBER; i++ {
		isAI := (strings.HasPrefix(playerIDs[i], "COMPUTER"))
		g.playerList[i] = Player{
			UID:             playerIDs[i],
			OutputUID:       outputPlayerUID[i],
			WaitLoadChannel: make(chan bool, CHAN_BUFFER),
			IsLoadDone:      isAI,
			IsPlayingGame:   playerIDs[i] != "",
			WaitReady:       make(chan bool, CHAN_BUFFER),
			WaitOneMore:     make(chan bool, CHAN_BUFFER),
			IsAI:            isAI,
		}
		if !isAI {
			realPlayer++
			specialUID = playerIDs[i]
		} else {
			SetSmartAI(&g.playerList[i])
		}
	}
	if SPECIAL_ON {
		if realPlayer == 1 {
			g.SpecialTrigger = g.CheckNeedSpecial(specialUID)
		} else {
			g.SpecialTrigger = 0
		}
	}
	fmt.Println("[normal] SetPlayer End: ", g.playerList)
}

type PlayerHistory struct {
	WinPeriod WinPeriod
}

type WinPeriod struct {
	KeepWin         int `firestore:"KeepWin"`
	KeepPeace       int `firestore:"KeepPeace"`
	LastWin         int `firestore:"LastWin"`
	IntervalBalance int `firestore:"IntervalBalance"`
}

func (g *GameRoom) CheckNeedSpecial(uid string) int {
	if !SPECIAL_ON {
		return 0
	}
	fmt.Println("[normal] Check Single Player NeedSpecial start.")
	pHistorySnapShot, err := FirebaseFunction.GetDocSnapShot(FirebaseFunction.PlayerHistoryColName, uid)
	if err != nil {
		fmt.Println("[ERROR] CheckNeedSpecial but get pHistorySnapShot err: ", uid, err)
		return 0
	}
	var pHData PlayerHistory
	err = pHistorySnapShot.DataTo(&pHData)
	if err != nil {
		fmt.Println("[ERROR] CheckNeedSpecial but dataTo pHData err: ", uid, err)
		return 0
	}
	pWinPeriod := pHData.WinPeriod
	fmt.Println("CheckNeedSpecial: ", pWinPeriod)

	if pWinPeriod.KeepWin >= 0 {
		return 0
	}

	if pWinPeriod.KeepWin < 0 {
		sIdx := -pWinPeriod.KeepWin
		sRates := []int{100, 100, 100, 100, 100}
		if sIdx > len(sRates)-1 {
			sIdx = len(sRates) - 1
		}
		tmpR := rand.New(rand.NewSource(time.Now().UnixNano()))
		r := tmpR.Intn(100)
		if r > sRates[sIdx] {
			fmt.Println("[Special] player:", uid, " ,over lose: ", pWinPeriod.KeepWin, " ,not pass: ", r, " > ", sRates[sIdx])
			return 0
		}
		fmt.Println("[Special] player:", uid, " ,over lose: ", pWinPeriod.KeepWin, " ,pass: ", r, " <= ", sRates[sIdx])
		return 1
	}

	return 0
}

func (g *GameRoom) PlayerJoin(conn net.Conn, encoder *json.Encoder, decoder *json.Decoder, playerID string) {
	index := -1
	for i := 0; i < PLAYER_NUMBER; i++ {
		if g.playerList[i].UID == playerID {
			index = i
		}
	}
	if index < 0 {
		fmt.Println("Could not find Player: ", playerID, g.playerList)
		conn.Close()
		return
	}
	//遊玩的玩家
	g.playerList[index].Connection = conn
	g.playerList[index].Encoder = encoder
	g.playerList[index].IsLoadDone = false
}

func (g *GameRoom) PlayerLeave(conn net.Conn) {
	g.MutexLock.Lock()
	defer g.MutexLock.Unlock()
	connectIndex := g.getPlayerIndex(conn)
	if connectIndex < 0 {
		//log.Printf("connect index < 0")
		return
	}
	//log.Printf("Player %d Leave", connectIndex)
	g.playerList[connectIndex].CloseConnection()
	g.playerList[connectIndex].IsLoadDone = false
	g.UpdatePlayerStatus()
}

func (g *GameRoom) HandleMessage(conn net.Conn, packet Packet.Packet, stop chan struct{}) error {
	connectIndex := g.getPlayerIndex(conn)
	if connectIndex < 0 {
		return errors.New("Player is not in connection list")
	}
	g.MutexLock.Lock()
	defer g.MutexLock.Unlock()
	conn.SetDeadline(time.Time{})
	g.playerList[connectIndex].TimeoutTime = time.Time{}
	//log.Printf("%d ReSetTimeout %v", connectIndex, g.playerList[connectIndex].TimeoutTime)
	switch packet.Command {
	case "LoadDone":
		//判斷中進
		if g.serverState != NoneInit {
			g.playerList[connectIndex].IsLoadDone = true
			g.playerList[connectIndex].leaveTimer = 0
			//送中進封包
			playerIndex := -1
			for id, value := range g.jamData.ActorOrder {
				if value == connectIndex {
					playerIndex = id
				}
			}
			if playerIndex == -1 {
				log.Printf("playerIndex Error")
				return nil
			}
			//log.Printf("Player Rejoin %v", playerIndex)
			g.HandleMidEnterPlayer(playerIndex)
			g.UpdatePlayerStatus()
		} else {
			if len(g.playerList[connectIndex].WaitLoadChannel) > 0 {
				for i := 0; i < CHAN_BUFFER; i++ {
					select {
					case <-g.playerList[connectIndex].WaitLoadChannel:
					default:
					}
				}
			}
			g.playerList[connectIndex].WaitLoadChannel <- true //PacketCommandID
		}
	case "ReadyPacket":
		if g.serverState == WaitNextRound {
			if len(g.playerList[connectIndex].WaitReady) > 0 {
				for i := 0; i < CHAN_BUFFER; i++ {
					select {
					case <-g.playerList[connectIndex].WaitReady:
					default:
					}
				}
			}
			g.playerList[connectIndex].ReadyNextRound = true
			g.playerList[connectIndex].WaitReady <- true
			g.UpdatePlayerStatus()
		}
	case "PachinkoDataPacket":
		playerIndex := -1
		for id, value := range g.jamData.ActorOrder {
			if value == connectIndex {
				playerIndex = id
			}
		}

		if playerIndex == -1 {
			if EnvironmentVersion != "Release" {
				log.Printf("PachinkoData playerIndex Error")
			}
			return nil
		}

		pachinkoDataPacket := PachinkoDataPacket{}
		if ok := pachinkoDataPacket.Parse(packet.Content); !ok {
			return errors.New("Parse PachinkoDataPacket Failed")
		}

		pachinkoData := pachinkoDataPacket.PachinkoData
		fmt.Println("PachinkoData from connectIdx: ", connectIndex, ", playerIdx: ", playerIndex, " Data: ", pachinkoData)
		fmt.Println("FromClientData: ", g.roundData.Pachinko.OutBallFromClient, g.roundData.Pachinko.BagBallFromClient, g.roundData.Pachinko.MagicCircleFromClient)
		if pachinkoData[0] > g.roundData.Pachinko.OutBallFromClient[playerIndex] {
			g.roundData.Pachinko.OutBallFromClient[playerIndex] = pachinkoData[0]
		}
		if pachinkoData[1] > g.roundData.Pachinko.BagBallFromClient[playerIndex] {
			g.roundData.Pachinko.BagBallFromClient[playerIndex] = pachinkoData[1]
		}
		if pachinkoData[2] > g.roundData.Pachinko.MagicCircleFromClient[playerIndex] {
			g.roundData.Pachinko.MagicCircleFromClient[playerIndex] = pachinkoData[2]
		}
		fmt.Println("=> ClientData: ", g.roundData.Pachinko.OutBallFromClient, g.roundData.Pachinko.BagBallFromClient, g.roundData.Pachinko.MagicCircleFromClient)

	case "PlayerAction":
		playerIndex := -1
		for id, value := range g.jamData.ActorOrder {
			if value == connectIndex {
				playerIndex = id
			}
		}
		if playerIndex == -1 {
			if EnvironmentVersion != "Release" {
				log.Printf("playerIndex Error")
			}
			return nil
		}
		//log.Printf("PlayerAction %v %d", g.WaitPlayerFlag[playerIndex], g.TellPlayerAction[playerIndex].ActionInfo.ID)
		if !g.WaitPlayerFlag[playerIndex] {
			if EnvironmentVersion != "Release" {
				log.Printf("%v is not waiting.", playerIndex)
			}
			return nil
		}

		actionContent := PlayerAction{}
		if ok := actionContent.Parse(packet.Content); !ok {
			return errors.New("Parse PlayerAction Failed")
		}

		ok, err := g.CheckActionValid(playerIndex, actionContent)
		if err != nil {
			return err
		}

		if ok && g.WaitPlayerAction[actionContent.PlayerIndex] != nil && len(g.WaitPlayerAction[actionContent.PlayerIndex]) < CHAN_BUFFER {
			log.Printf("Handle Action ID %d", actionContent.ID)
			g.WaitPlayerAction[actionContent.PlayerIndex] <- actionContent
		}
	case "NotifyPUNRoomPacket":
		//log.Printf("Recieve NotifyPUNRoomPacket at %v", g.serverState)
		// if g.serverState == NotifyEndGame || g.serverState == WaitOneMoreGame || g.serverState == ShutdownServer {
		// 	roomPacket := NotifyPUNRoomPacket{}
		// 	if ok := roomPacket.Parse(packet.Content); !ok {
		// 		return errors.New("Parse NotifyPUNRoomPacket Failed")
		// 	}
		// 	g.broadCastPacket(&Packet.Packet{
		// 		Command:  "NOTIFY_PUN_ROOM",
		// 		PacketID: -1,
		// 		Content: NotifyPUNRoomPacket{
		// 			RoomName: roomPacket.RoomName,
		// 		},
		// 	})
		// } else {
		// 	log.Printf("Player Try To Create PUN Room, but not in end game state.")
		// }
	case "ForceLeftPacket":
		// if (g.GameRoomSetting.RoomType == "Friend") || g.AllowAbandonRoom {
		// 	leftPacket := ForceLeftPacket{}
		// 	if ok := leftPacket.Parse(packet.Content); !ok {
		// 		return errors.New("Parse ForceLeftPacket Failed")
		// 	}
		// 	if g.playerList[connectIndex].UID != leftPacket.UID {
		// 		log.Printf("Player try to left game with error UID.")
		// 		return nil
		// 	}
		// 	isAllLife := true
		// 	g.playerList[connectIndex].IsPlayingGame = false
		// 	g.playerList[connectIndex].leaveTimer = MAX_ALLOW_DISCONNECT_TIME
		// 	playerIDList := make([]string, PLAYER_NUMBER)
		// 	for i := 0; i < PLAYER_NUMBER; i++ {
		// 		if g.playerList[i].IsPlayingGame {
		// 			if !g.playerList[i].IsAI {
		// 				isAllLife = false
		// 			}
		// 			playerIDList[i] = g.playerList[i].UID
		// 		} else {
		// 			playerIDList[i] = ""
		// 		}
		// 	}
		// 	//log.Printf("Player %d force left Game. %s", connectIndex, leftPacket.UID)
		// 	FirebaseFunction.UpdateGameRoom(g.FirebaseDocID, playerIDList)
		// 	//如果未來禮物模式要可以讓玩家離開 把玩家東西還回去
		// 	g.UpdatePlayerStatus()
		// 	if isAllLife {
		// 		g.endGame(false, nil)
		// 		stop <- struct{}{}
		// 	}
		// } else {
		// 	log.Printf("Player try to left game with error game type.")
		// }
	case "OneMoreGamePacket":
		// if g.serverState == WaitOneMoreGame {
		// 	moreGamePacket := OneMoreGamePacket{}
		// 	if ok := moreGamePacket.Parse(packet.Content); !ok {
		// 		return errors.New("Parse OneMoreGamePacket Failed")
		// 	}
		// 	if len(g.playerList[connectIndex].WaitOneMore) > 0 {
		// 		for i := 0; i < CHAN_BUFFER; i++ {
		// 			select {
		// 			case <-g.playerList[connectIndex].WaitOneMore:
		// 			default:
		// 			}
		// 		}
		// 	}
		// 	g.playerList[connectIndex].ReadyNextRound = moreGamePacket.OneMoreGame
		// 	g.playerList[connectIndex].WaitOneMore <- moreGamePacket.OneMoreGame
		// 	g.UpdatePlayerStatus()
		// }
	case "EmojiPacket":
		playerIndex := -1
		for id, value := range g.jamData.ActorOrder {
			if value == connectIndex {
				playerIndex = id
			}
		}
		if playerIndex == -1 {
			if EnvironmentVersion != "Release" {
				log.Printf("playerIndex Error")
			}
			return nil
		}
		emojiPacket := EmojiPacket{}
		if ok := emojiPacket.Parse(packet.Content); !ok {
			return errors.New("Parse EmojiPacket Failed")
		}
		g.broadCastPacket(&Packet.Packet{
			Command:  "Emoji",
			PacketID: -1,
			Content:  emojiPacket,
		})
		fmt.Println("Player UseEmoji:", playerIndex, " ,connectIdx:", connectIndex, " ,UID", g.playerList[connectIndex].UID)
		g.playerList[connectIndex].UseEmoji += 1

	case "OpenDiscardSeaPacket":
		playerIndex := -1
		for id, value := range g.jamData.ActorOrder {
			if value == connectIndex {
				playerIndex = id
			}
		}
		if playerIndex == -1 {
			if EnvironmentVersion != "Release" {
				log.Printf("[OpenDiscardSea] playerIndex Error")
			}
			return nil
		}
		g.playerList[connectIndex].OpenDiscardSea += 1
		//log.Printf("PlayerAction %v %d", g.WaitPlayerFlag[playerIndex], g.TellPlayerAction[playerIndex].ActionInfo.ID)

		if !g.WaitPlayerFlag[playerIndex] {
			if EnvironmentVersion != "Release" {
				log.Printf("[OpenDiscardSea] %v is not waiting.", playerIndex)
			}
			return nil
		}

		if playerIndex != g.currentActionPlayer {
			if EnvironmentVersion != "Release" {
				log.Printf("[OpenDiscardSea] %d is not the currentActionPlayer, %d.", playerIndex, g.currentActionPlayer)
			}
			return nil
		}

		if g.WaitOpenDiscardSeaFlag[playerIndex] {
			if EnvironmentVersion != "Release" {
				log.Printf("[OpenDiscardSea] %v already waitOpenDiscardSeaFlag.", playerIndex)
			}
			return nil
		}

		g.WaitOpenDiscardSeaFlag[playerIndex] = true
		fmt.Println("[OpenDiscardSea] Player OpenDiscardSea:", playerIndex, " ,connectIdx:", connectIndex, " ,UID", g.playerList[connectIndex].UID)
	}
	return nil
}

func (g *GameRoom) getPlayerIndex(conn net.Conn) int {
	for i := 0; i < PLAYER_NUMBER; i++ {
		if g.playerList[i].Connection == conn {
			return i
		}
	}
	return -1
}

func (g *GameRoom) StartRun(stop chan struct{}, endGame chan struct{}) {
	go g.gameUpdate(stop, endGame)
	go g.UpdatePlayerLeaveTime(stop)
	go g.CheckIsStuck(stop)
}

func (g *GameRoom) CheckIsStuck(stop chan struct{}) {
	defer func() {
		if err := recover(); err != nil {
			fmt.Printf("CheckIsStuck error: %v.\n%s", err, string(debug.Stack()))
			stop <- struct{}{}
		}
	}()
	timer := time.NewTicker(15 * time.Second)
	g.lastChangeStateTime = time.Now()
	for {
		<-timer.C
		elapsed := time.Since(g.lastChangeStateTime)
		if (elapsed.Minutes()) >= 3 && g.serverState != ShutdownServer {
			pprof.Lookup("goroutine").WriteTo(os.Stdout, 1)
			g.WriteGameErrorLog(ERROR_STATE_STUCK, map[string]interface{}{
				"ServerState":    g.serverState,
				"DebugIsRunning": g.DebugIsRunning,
				"CreateTime":     time.Now(),
			})
			stop <- struct{}{}
		}
	}
}

func (g *GameRoom) gameUpdate(stop chan struct{}, endGame chan struct{}) {
	defer func() {
		g.DebugIsRunning = false
		if err := recover(); err != nil {
			fmt.Printf("gameUpdate error: %v.\n%s", err, string(debug.Stack()))
			stop <- struct{}{}
		}
	}()
	for {
		g.DebugIsRunning = true
		//log.Printf("ServerState : %v", g.serverState)
		switch g.serverState {
		case NoneInit:
			log.Println("gameUpdate: waitLoadDone")
			g.serverState = g.waitLoadDone( /*stateDone,*/ stop)
		case StartGame:
			log.Println("gameUpdate: startGame")
			g.serverState = g.startGame(stop)
		case StartRound:
			g.serverState = g.startRound(stop)
		case DealCard:
			g.serverState = g.dealCard(stop)
		case NotifyHeavenListen:
			g.serverState = g.notifyHeavenListen(stop)
			g.ResetBeforeSwitchPlayer()
			fmt.Println("NotifyHeavenListen END")
		case EndHeavenListen:
			g.serverState = g.waitHeavenListen( /*stateDone,*/ stop)
			fmt.Println("EndHeavenListen END")
		case NotifyDiscardTile:
			g.serverState = g.playerDiscardTile(g.isFirstDealer, g.isCurrentPlayerKongOther, stop)
			fmt.Println("NotifyDiscardTile END")
			//g.isFirstDealer = false
		case EndDiscardTile:
			g.serverState = g.waitPlayerDiscardTile( /*stateDone,*/ stop)
			fmt.Println("EndDiscardTile END")
		case NotifyRobWin:
			g.serverState = g.checkRobKongWin(stop)
		case EndRobWin:
			g.serverState = g.waitRobKongWin( /*stateDone,*/ stop)
		case NotifyAfterDiscard:
			g.serverState = g.checkAfterDiscardTile(stop)
		case EndAfterDiscard:
			g.serverState = g.waitAfterDiscardTile( /*stateDone,*/ stop)
		case NotifyWinInfo:
			g.CallPachinkoData()
			time.Sleep(1500 * time.Millisecond)
			fmt.Println("[=== Normal ===] NotifyWinInfo, Already Sleep: 1500 ms.")
			g.serverState = g.handleWinScores(stop)
		case WaitNextRound:
			fmt.Println("[=== Normal ===] WaitNextRound")
			g.serverState = g.waitNextRound( /*stateDone,*/ stop)
			g.ActionPacketID++
		case WaitNotifyEndGame:
			fmt.Println("[=== Normal ===] WaitNotifyEndGame")
			g.serverState = g.waitNotifyEndGame( /*stateDone,*/ stop)
			g.ActionPacketID++
		case NotifyEndGame:
			fmt.Println("[=== Normal ===] NotifyEndGame")
			state, canOneMore := g.endGame(true, stop)
			g.serverState = state
			if !canOneMore {
				fmt.Println("endGame <- from NotifyEndGame")
				endGame <- struct{}{}
				return
			}
		case WaitOneMoreGame:
			fmt.Println("gameUpdate: WaitOneMoreGame")
			g.serverState = g.waitOneMoreGame( /*stateDone,*/ stop)
			if g.serverState == ShutdownServer {
				g.broadCastPacket(&Packet.Packet{
					Command:  "NO_MORE_GAME",
					PacketID: -1,
					Content:  nil,
				})
				fmt.Println("endGame <- from WaitOneMoreGame")
				endGame <- struct{}{}
				return
			}
			//再來一局
		case ShutdownServer:
			fmt.Println("gameUpdate: ShutdownServer")
			return
		}
		g.lastChangeStateTime = time.Now()
		select {
		case <-stop:
			g.serverState = ShutdownServer
		default:
		}
	}
}

func (g *GameRoom) ChangeState(state ServerState) {
	//log.Printf("Change State : %v", state)
	g.DebugLastState = g.serverState
	g.serverState = state
}

func (g *GameRoom) CallPachinkoData() {
	g.broadCastPacket(&Packet.Packet{
		Command:  "CALL_PACHINKO_DATA",
		PacketID: -1,
		Content:  nil,
	})
}

func (g *GameRoom) ResetBeforeSwitchPlayer() {
	g.currentPlayerDrawTile = -1
	g.roundData.AddTurnCount()
	g.isCurrentPlayerKongOther = g.lastPlayerActionType == ExposedKong
	g.roundData.GetPlayerCardInfo(g.currentActionPlayer).SetLastDiscardTile(-1)
}

func (g *GameRoom) broadCastPacket(packet *Packet.Packet) {
	anyError := false
	for i := 0; i < PLAYER_NUMBER; i++ {
		if g.playerList[i].Connection == nil || !g.playerList[i].IsLoadDone {
			continue
		}
		err := Packet.SendPacket(g.playerList[i].Encoder, packet)
		if err != nil {
			log.Printf("broadCastPacket with error %v", err.Error())
			anyError = true
		}
	}
	if anyError {
		g.UpdatePlayerStatus()
	}
}

func (g *GameRoom) sendPacketToPlayer(playerIndex int, packet *Packet.Packet) {
	connectIndex := g.jamData.ActorOrder[playerIndex]
	if g.playerList[connectIndex].Connection == nil || !g.playerList[connectIndex].IsLoadDone {
		return
	}
	if (packet.Command == "TELL_PLAYER_ACTION" && g.playerList[connectIndex].TimeoutTime.Equal(time.Time{})) {
		g.playerList[connectIndex].TimeoutTime = time.Now().Add(TellTimeOut * time.Minute)
		g.playerList[connectIndex].Connection.SetReadDeadline(g.playerList[connectIndex].TimeoutTime)
		log.Printf("%d SetTimeout %v", connectIndex, g.playerList[connectIndex].TimeoutTime)
	}
	err := Packet.SendPacket(g.playerList[connectIndex].Encoder, packet)
	if err != nil {
		log.Printf("sendPacketToPlayer with error %v", err.Error())
		g.playerList[connectIndex].CloseConnection()
		g.UpdatePlayerStatus()
	}
}

func (g *GameRoom) SetPlayerWaiting(playerIndex int, addTime float64) float64 {
	g.WaitPlayerFlag[playerIndex] = true
	g.WaitPlayerAction[playerIndex] = make(chan PlayerAction, CHAN_BUFFER)
	g.WaitPlayerTime[playerIndex] = g.GetWaitTime(playerIndex)
	if g.IsPlayerInRoom(playerIndex) {
		g.WaitPlayerTime[playerIndex] += addTime
	}
	return g.WaitPlayerTime[playerIndex]
}

//照每個人等待時間不同
func (g *GameRoom) GetWaitTime(playerIndex int) float64 {
	if g.IsPlayerInRoom(playerIndex) {
		return g.RoomWaitTime
	} else {
		return AI_WAIT_TIME_MAX
	}
}

func (g *GameRoom) IsPlayerInRoomRightNow(playerIndex int) bool {
	connectIndex := g.jamData.ActorOrder[playerIndex]
	if g.playerList[connectIndex].Connection != nil || g.IsPlayerAI(playerIndex) {
		return true
	} else {
		return false
	}
}

func (g *GameRoom) IsPlayerInRoom(playerIndex int) bool {
	connectIndex := g.jamData.ActorOrder[playerIndex]
	if g.playerList[connectIndex].Connection != nil || g.IsPlayerAI(playerIndex) {
		return true
	} else {
		return g.playerList[connectIndex].leaveTimer < MAX_ALLOW_DISCONNECT_TIME
	}
}

func (g *GameRoom) GetPlayerStatus() [PLAYER_NUMBER]PlayerStatus {
	playerStatusList := [PLAYER_NUMBER]PlayerStatus{}
	for i := 0; i < PLAYER_NUMBER; i++ {
		playerStatusList[i].ActorNumber = i
		playerStatusList[i].IsLoadDone = g.playerList[i].IsLoadDone
		playerStatusList[i].UID = g.playerList[i].UID
		playerStatusList[i].IsConnect = g.playerList[i].Connection != nil
		playerStatusList[i].IsPlayingGame = g.playerList[i].IsPlayingGame
		playerStatusList[i].ReadyNextRound = g.playerList[i].ReadyNextRound
		playerStatusList[i].OneMoreGame = g.playerList[i].OneMoreGame
		playerStatusList[i].IsAI = g.playerList[i].IsAI
	}
	return playerStatusList
}

func (g *GameRoom) UpdatePlayerStatus() {
	g.broadCastPacket(&Packet.Packet{
		Command:  "UPDATE_ROOM_STATUS",
		PacketID: -1,
		Content: &UpdateRoomPacket{
			PlayerStatusList: g.GetPlayerStatus(),
		},
	})
}

func (g *GameRoom) UpdatePlayerLeaveTime(stop chan struct{}) {
	defer func() {
		if err := recover(); err != nil {
			fmt.Printf("UpdatePlayerLeaveTime error: %v.\n%s", err, string(debug.Stack()))
			stop <- struct{}{}
		}
	}()
	ticker := time.NewTicker(time.Duration(200) * time.Millisecond)
	for {
		select {
		case <-ticker.C:
			g.MutexLock.Lock()
			g.ServerTime += TIME_UPDATE_INTERVAL_MS / 1000
			for i := 0; i < PLAYER_NUMBER; i++ {
				if g.playerList[i].Connection == nil && !g.playerList[i].IsAI {
					if g.playerList[i].leaveTimer < MAX_ALLOW_DISCONNECT_TIME {
						g.playerList[i].leaveTimer += TIME_UPDATE_INTERVAL_MS / 1000
					} else {
						g.playerList[i].leaveTimer = MAX_ALLOW_DISCONNECT_TIME
					}
				} else {
					g.playerList[i].leaveTimer = 0
				}
			}
			g.MutexLock.Unlock()
		case <-stop:
			return
		}
	}
}

func (g *GameRoom) CheckActionValid(playerIndex int, actionContent PlayerAction) (bool, error) {
	if playerIndex != actionContent.PlayerIndex {
		//log.Printf("Error Player index not the same.")
		return false, errors.New("Error Player index not the same.")
	}
	//先判斷封包ID是不是這次行動
	if g.TellPlayerAction[playerIndex] == nil || g.TellPlayerAction[playerIndex].ActionInfo.ID != actionContent.ID {
		if EnvironmentVersion != "Release" {
			log.Printf("ActionInfo.ID not the same.")
		}
		return false, nil
	}

	if (g.TellPlayerAction[playerIndex].ActionInfo.CanActions & actionContent.ActionType) != actionContent.ActionType {
		fmt.Println("ActionERROR: ", g.TellPlayerAction[playerIndex].ActionInfo.CanActions, actionContent.ActionType)
		g.sendPacketToPlayer(playerIndex, &Packet.Packet{
			Command:  "ACTION_ERROR",
			PacketID: -1,
			Content:  nil,
		})
		return false, errors.New("ACTION_ERROR")
	}
	//要打一張牌的情況
	switch actionContent.ActionType {
	case NoneAction:
		if g.TellPlayerAction[playerIndex].ActionInfo.CanActions != NoneAction {
			g.sendPacketToPlayer(playerIndex, &Packet.Packet{
				Command:  "ACTION_ERROR",
				PacketID: -1,
				Content:  nil,
			})
			return false, errors.New("ACTION_ERROR")
		}
	case Discard:
		if !IntArrayContain(g.TellPlayerAction[playerIndex].CanDiscardList, actionContent.TileID) {
			g.sendPacketToPlayer(playerIndex, &Packet.Packet{
				Command:  "ACTION_ERROR",
				PacketID: -1,
				Content:  nil,
			})
			g.WriteGameErrorLog(ERROR_ACTION, map[string]interface{}{
				"ActionType":      actionContent.ActionType,
				"CanDiscardList":  g.TellPlayerAction[playerIndex].CanDiscardList,
				"ActionTile":      actionContent.TileID,
				"CreateTime":      time.Now(),
				"TellCanAction":   g.TellPlayerAction[playerIndex].ActionInfo.CanActions,
				"TellActionTile":  g.TellPlayerAction[playerIndex].ActionInfo.ActionTileID,
				"PlayingRoomName": g.FirebaseDocID,
				"RoundLen":        len(g.jamData.roundDataList),
				"PlayerIndex":     playerIndex,
				"RoundStep":       len(g.roundData.GetActionLog()),
			})
			return false, errors.New("ACTION_ERROR")
		}
	case EarthListen:
		fallthrough
	case NotifyListen:
		isInKey := false
		for key, _ := range g.TellPlayerAction[playerIndex].CanListenList {
			if key == actionContent.TileID {
				isInKey = true
				break
			}
		}
		if !isInKey {
			g.sendPacketToPlayer(playerIndex, &Packet.Packet{
				Command:  "ACTION_ERROR",
				PacketID: -1,
				Content:  nil,
			})
			canListenTiles := make([]int, 0, len(g.TellPlayerAction[playerIndex].CanListenList))
			for key, _ := range g.TellPlayerAction[playerIndex].CanListenList {
				canListenTiles = append(canListenTiles, key)
			}
			g.WriteGameErrorLog(ERROR_ACTION, map[string]interface{}{
				"ActionType":        actionContent.ActionType,
				"CanDiscardList":    g.TellPlayerAction[playerIndex].CanDiscardList,
				"ActionTile":        actionContent.TileID,
				"CanListenTileList": canListenTiles,
				"CreateTime":        time.Now(),
			})
			return false, errors.New("ACTION_ERROR")
		}
	case Chow:
		inList := false
		for _, meldList := range g.TellPlayerAction[playerIndex].CanChowList {
			if IntArrayCompare(meldList.Tiles, actionContent.MeldTiles) {
				inList = true
				break
			}
		}
		if !inList {
			g.sendPacketToPlayer(playerIndex, &Packet.Packet{
				Command:  "ACTION_ERROR",
				PacketID: -1,
				Content:  nil,
			})
			g.WriteGameErrorLog(ERROR_ACTION, map[string]interface{}{
				"ActionType":      actionContent.ActionType,
				"CanChowList":     g.TellPlayerAction[playerIndex].CanChowList,
				"ActionMeldTiles": actionContent.MeldTiles,
				"CreateTime":      time.Now(),
			})
			return false, errors.New("ACTION_ERROR")
		}
	case Pong:
		if !IntArrayCompare(g.TellPlayerAction[playerIndex].CanPongList.Tiles, actionContent.MeldTiles) {
			g.sendPacketToPlayer(playerIndex, &Packet.Packet{
				Command:  "ACTION_ERROR",
				PacketID: -1,
				Content:  nil,
			})
			g.WriteGameErrorLog(ERROR_ACTION, map[string]interface{}{
				"ActionType":      actionContent.ActionType,
				"CanChowList":     g.TellPlayerAction[playerIndex].CanPongList,
				"ActionMeldTiles": actionContent.MeldTiles,
				"CreateTime":      time.Now(),
			})
			return false, errors.New("ACTION_ERROR")
		}
	case ExposedKong:
		fallthrough
	case AddKong:
		inList := false
		for _, meldList := range g.TellPlayerAction[playerIndex].CanKongList {
			if IntArrayCompare(meldList.Tiles, actionContent.MeldTiles) {
				inList = true
				break
			}
		}
		if !inList {
			g.sendPacketToPlayer(playerIndex, &Packet.Packet{
				Command:  "ACTION_ERROR",
				PacketID: -1,
				Content:  nil,
			})
			g.WriteGameErrorLog(ERROR_ACTION, map[string]interface{}{
				"ActionType":      actionContent.ActionType,
				"CanChowList":     g.TellPlayerAction[playerIndex].CanKongList,
				"ActionMeldTiles": actionContent.MeldTiles,
				"CreateTime":      time.Now(),
			})
			return false, errors.New("ACTION_ERROR")
		}
	case ConcealedKong:
		inList := false
		for _, meldList := range g.TellPlayerAction[playerIndex].CanConcealedKongList {
			if IntArrayCompare(meldList.Tiles, actionContent.MeldTiles) {
				inList = true
				break
			}
		}
		if !inList {
			g.sendPacketToPlayer(playerIndex, &Packet.Packet{
				Command:  "ACTION_ERROR",
				PacketID: -1,
				Content:  nil,
			})
			g.WriteGameErrorLog(ERROR_ACTION, map[string]interface{}{
				"ActionType":      actionContent.ActionType,
				"CanChowList":     g.TellPlayerAction[playerIndex].CanConcealedKongList,
				"ActionMeldTiles": actionContent.MeldTiles,
				"CreateTime":      time.Now(),
			})
			return false, errors.New("ACTION_ERROR")
		}
	}
	return true, nil
}

// 萬筒條字
func (g *GameRoom) GetWinPointRate(tileType int) int {
	rate := g.GetAllWinPointRate()
	return rate[tileType]
}

func (g *GameRoom) GetAllWinPointRate() [5]int {
	rate := [5]int{1, 1, 1, 1, 1}
	bagBallNum := [5]int{0, 0, 0, 0, 0}
	pachinkoData := g.roundData.Pachinko.GetRevisedPachinkoData()
	allBagBallNum := pachinkoData[1]

	fmt.Println("GetAllWinPointRateStart: ", bagBallNum, pachinkoData, allBagBallNum)

	pushRecord := []int{}
	for i := 0; i < pachinkoData[1]; i++ {
		bag := g.roundData.Pachinko.GoalSlotRecord[i%len(g.roundData.Pachinko.GoalSlotRecord)]
		bagBallNum[bag]++
		pushRecord = append(pushRecord, bag)
	}

	allFull := true
	for i := 1; i < len(rate); i++ { // 0是未進洞
		if bagBallNum[i] >= g.GameRoomSetting.FullBagBalls {
			rate[i] = g.roundData.Pachinko.FullRewardRate[i]
		} else {
			allFull = false
		}
	}

	if allFull {
		allFullRate := g.roundData.Pachinko.AllFullRewardRate
		rate = [5]int{allFullRate, allFullRate, allFullRate, allFullRate, allFullRate}
		fmt.Println("GetAllWinPointRateByData: ", pachinkoData)
		fmt.Println("GetAllWinPointRateEnd: (AllFull)BagBallNum:", bagBallNum, " ,pachinkoData:", pachinkoData, " ,pushRecord:", pushRecord)
		fmt.Println("Rate => ", rate)
		return rate
	}

	fmt.Println("GetAllWinPointRateEnd: BagBallNum:", bagBallNum, " ,pachinkoData:", pachinkoData, " ,pushRecord:", pushRecord)
	fmt.Println("GetAllWinPointRateByData: ", pachinkoData)
	fmt.Println("Rate => ", rate, "(", g.roundData.Pachinko.FullRewardRate, ")")
	return rate
}
